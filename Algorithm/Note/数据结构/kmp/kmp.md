# kmp
KMP模式匹配算法
## [KMP字符串](https://www.acwing.com/problem/content/description/833/)
### KMP基本概念
1. s\[ \]是_模式串_，即比较长的字符串。  
2. p\[ \]是_模板串_，即比较短的字符串。
3. “非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。  
4. “非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。（后面会有例子，均简称为前/后缀）  
5. “部分匹配值”：_前缀_和_后缀_的**最长共有**元素的**长度**。  
6. next\[ \]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是KMP算法的**核心**。（后面作详细讲解）。

**核心思想**：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next\[ \]数组确定的。
### next数组
定义：对于`next[j]`,是p[1,j]串中前缀和后缀相同的最大长度。
即：`p[1 , next[j]] = p[j - next[j] + 1 , j]`

如：
对于p = "abcab":
| p | a | b | c | a | b |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 下标 | 1 | 2 | 3 | 4 | 5 |
| next\[ \] | 0 | 0 | 0 | 1 | 2 |

### 匹配思路
![kmppipei](https://cdn.acwing.com/media/article/image/2020/06/12/31041_8e70c3eeac-%E5%8C%B9%E9%85%8D.PNG)

当i指针与j+1指针不匹配时，将p串移动到下一次可匹配的位置
这个操作可由j = next[j]完成
循环此步骤，当j==m时即可匹配成功

```c++
for(int i = 1 , j = 0;i <= n;i ++){
    while(j > 0 && s[i] != p[j+1]) j = ne[j];

    if(s[i] == p[j+1]) j ++;
    if(j == m) 
    {
        cout << i - m ;
        j = next[j];
    }
}
```
### 求next
![Img](https://cdn.acwing.com/media/article/image/2020/06/12/31041_97225cdcac-next%E6%95%B0%E7%BB%84.PNG)
```c++
for(int i = 2, j = 0;i <= m;i ++){
    while(j && p[i] != p[j+1]) j = next[j];
    if(p[i] == p[j+1]) j ++;
    next[i] = j;
}
```